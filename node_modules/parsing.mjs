import {open} from 'node:fs/promises';
import {
	getSubstringAfterSubstring, 
	getSubstringBeforeSubstring
} from './substrings.mjs';

// Array of all emojis

const emojis = [];

// Array of all zwj-emojis

const emojisZwj = [];

// Aux arrays for searching and selecting

const allGroupsNames = [];
const allSubgroupsNames = [];
const allSequenceNames = [];
const allSequencesTotals = [];
const allGroupsTotals = [];

const parsingUnicodeEmojisFile = async function(unicodeFileName) {
	try {
		const unicodeFile = await open(unicodeFileName);
		let currentGroup = '';	// Emoji group name
		let currentGroupId = -1;
		let currentSubgroup = '';	// Emoji subgroup name
		let currentSubgroupId = -1;	// Emoji subgroup id
		let currentSequence = '';	// Sequence name
		let currentSequenceId = -1;

		for await (let line of unicodeFile.readLines()) {
			line = line.trim();
			if (line === '') {
				continue;
			}
			let tempSubstring = '';
			const lineStartChar = line.charAt(0);

			// Getting Group/Subgroup/Sequence

			if (lineStartChar === '#') {

				// Getting group name
				if (tempSubstring = getSubstringAfterSubstring(line, ' group:')) {
					currentGroup = tempSubstring;
					currentGroupId = allGroupsNames.push(currentGroup) - 1; 

				// Getting subgroup name
				} else if (tempSubstring = getSubstringAfterSubstring(line, ' subgroup:')) {
					currentSubgroup = tempSubstring;
					if (!Array.isArray(allSubgroupsNames[allGroupsNames.length - 1])) {
						allSubgroupsNames[allGroupsNames.length - 1] = [];
					}
					currentSubgroupId = allSubgroupsNames[allGroupsNames.length - 1].push(currentSubgroup) - 1;

				// Getting sequence name
				} else if (tempSubstring = getSubstringAfterSubstring(line, ' rgi_emoji_zwj_sequence:')) {
					currentSequence = tempSubstring;
					currentSequenceId = allSequenceNames.push(currentSequence) - 1;

				// Getting the sequence total
				} else if (tempSubstring = getSubstringAfterSubstring(line, ' Total elements:')) {
					allSequencesTotals[currentSequenceId] = parseInt(tempSubstring);

				// Getting the group total
				} else if ((tempSubstring = getSubstringAfterSubstring(line, ' subtotal:')) && !isNaN(Number(tempSubstring))) {
					allGroupsTotals[currentGroupId] = Number(tempSubstring);
				}

			} else {

				// Getting emoji

				const emojiObj = {
					originalStr: line,
					codePointsStr: '',
					codePointsArr: null,
					group: currentGroup,
					groupId: currentGroupId,
					subgroup: currentSubgroup,
					subgroupId: currentSubgroupId,
					sequence: currentSequence,
					sequenceId: currentSequenceId,
					status: '',
					comment: '',
					name: ''
				};

				const lineArr = line.split(';');
				emojiObj.codePointsStr = lineArr[0].trim();
				emojiObj.codePointsArr = emojiObj.codePointsStr.split(' ');

				if (lineArr.length == 3) {	// Sequence
					emojiObj.name = getSubstringBeforeSubstring(lineArr[2], '#').trim();
					emojiObj.comment = getSubstringAfterSubstring(lineArr[2], '#').trim();
				} else {	// Not sequence	
					emojiObj.status = getSubstringBeforeSubstring(lineArr[1], '#').trim();
					emojiObj.comment = getSubstringAfterSubstring(lineArr[1], '#').trim();
					if (emojiObj.comment) {
						const re = /.*e\d+\.\d+ /gi;
						const commentArr =  emojiObj.comment.split(re);
						emojiObj.name = commentArr[1] === undefined ? commentArr[0].trim() : commentArr[1].trim();
					}
				}
				if (emojiObj.group && !emojiObj.sequence) {
					emojis.push(emojiObj);
				}
				if (!emojiObj.group && emojiObj.sequence) {
					emojisZwj.push(emojiObj);
				}
			}		
		}
		await unicodeFile.close();
	} catch(error) {
		console.error(error.message);
	}	
};

export {
	parsingUnicodeEmojisFile,
	allGroupsNames,
	allSubgroupsNames,
	allSequenceNames,
	emojis,
	emojisZwj,
	allSequencesTotals,
	allGroupsTotals
};